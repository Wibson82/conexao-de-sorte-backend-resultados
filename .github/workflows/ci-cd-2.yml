name: "🎯 Resultados Backend - CI/CD Pipeline (Self-hosted Deploy)"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SERVICE_NAME: resultados
  STACK_NAME: conexao-resultados
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write
  contents: read

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
      keyvault_name: ${{ steps.check_secrets.outputs.keyvault_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "✅ docker-compose.yml válido"

      - name: Security Validation
        run: |
          echo "🔍 Verificando senha hardcoded em docker-compose.yml..."
          if grep -nE "password\s*:\s*[^[:space:]]+" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external"; then
            echo "❌ Encontrada senha potencialmente hardcoded"
            exit 1
          fi
          echo "✅ Sem senhas hardcoded detectadas"

      - name: 🔎 Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID || secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_ENDPOINT: ${{ vars.AZURE_KEYVAULT_ENDPOINT || secrets.AZURE_KEYVAULT_ENDPOINT }}
          AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME || secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '❌ GitHub Secrets obrigatórios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "✅ Identificadores Azure configurados"

          keyvault_name=""
          if [[ -n "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            keyvault_name=$(echo "$AZURE_KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net.*|\1|')
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            echo "keyvault_name=$keyvault_name" >> "$GITHUB_OUTPUT"
            echo "✅ Usando Key Vault informado via endpoint (${keyvault_name})"
          elif [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            keyvault_name="$AZURE_KEYVAULT_NAME"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            echo "keyvault_name=$keyvault_name" >> "$GITHUB_OUTPUT"
            echo "✅ Usando Key Vault informado via nome (${keyvault_name})"
          else
            echo "❌ Nenhum Key Vault configurado para o serviço resultados"
            exit 1
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validation completed
        run: echo "✅ Validação concluída - pipeline liberado para deploy"

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-backend-resultados]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: 🔐 Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ✅ Validar sessão Azure
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        run: |
          echo "🔍 Validando sessão Azure..."
          az account show >/dev/null 2>&1 || { echo "❌ Falha na autenticação Azure"; exit 1; }
          echo "✅ Azure autenticado (subscription $(az account show --query id -o tsv))"

      - name: 🔑 Buscar segredos no Azure Key Vault
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        env:
          KEYVAULT_NAME: ${{ needs.validate-and-build.outputs.keyvault_endpoint }}
        run: |
          set -Eeuo pipefail
          if [[ -z "${KEYVAULT_NAME}" ]]; then
            echo "❌ Nome do Key Vault não definido"
            exit 1
          fi
          echo "🔍 Lendo segredos do Key Vault ${KEYVAULT_NAME}"
          SECRETS=(
            conexao-de-sorte-database-r2dbc-url
            conexao-de-sorte-database-jdbc-url
            conexao-de-sorte-database-username
            conexao-de-sorte-database-password
            conexao-de-sorte-redis-host
            conexao-de-sorte-redis-port
            conexao-de-sorte-redis-password
            conexao-de-sorte-redis-database
            conexao-de-sorte-jwt-secret
            conexao-de-sorte-jwt-issuer
            conexao-de-sorte-jwt-jwks-uri
            conexao-de-sorte-jwt-refresh-token-validity
            conexao-de-sorte-jwt-access-token-validity
            conexao-de-sorte-jwt-cleanup-interval
          )
          for secret_name in "${SECRETS[@]}"; do
            echo "🔐 Secret: ${secret_name}"
            secret_value=$(az keyvault secret show --vault-name "${KEYVAULT_NAME}" --name "${secret_name}" --query value -o tsv 2>/dev/null || true)
            if [[ -n "${secret_value}" ]]; then
              env_var=$(echo "${secret_name}" | tr '-' '_' | tr '[:lower:]' '[:upper:]')
              echo "${env_var}=${secret_value}" >> $GITHUB_ENV
              echo "::add-mask::${secret_value}"
            else
              echo "⚠️ Secret '${secret_name}' não encontrado - mantendo deploy, porém verifique Key Vault"
            fi
          done
          echo "✅ Segredos processados"

      - name: 🗄️ Garantir secrets do Docker Swarm
        run: |
          set -Eeuo pipefail
          ensure_secret() {
            local secret_name="$1"
            local value="$2"
            if [[ -z "$value" ]]; then
              echo "❌ Valor não fornecido para o secret $secret_name"
              exit 1
            fi
            if docker secret ls --format '{{.Name}}' | grep -q "^${secret_name}$"; then
              echo "ℹ️ Secret ${secret_name} já existe, atualizando"
              docker secret rm "$secret_name" >/dev/null 2>&1 || true
            fi
            printf "%s" "$value" | docker secret create "$secret_name" - >/dev/null
            echo "✅ Secret ${secret_name} disponível"
          }
          ensure_secret "conexao-de-sorte-database-username" "${CONEXAO_DE_SORTE_DATABASE_USERNAME:-}"
          ensure_secret "conexao-de-sorte-database-password" "${CONEXAO_DE_SORTE_DATABASE_PASSWORD:-}"
          ensure_secret "conexao-de-sorte-database-r2dbc-url" "${CONEXAO_DE_SORTE_DATABASE_R2DBC_URL:-}"
          ensure_secret "conexao-de-sorte-database-jdbc-url" "${CONEXAO_DE_SORTE_DATABASE_JDBC_URL:-}"
          ensure_secret "conexao-de-sorte-redis-password" "${CONEXAO_DE_SORTE_REDIS_PASSWORD:-}"
          ensure_secret "conexao-de-sorte-jwt-secret" "${CONEXAO_DE_SORTE_JWT_SECRET:-}"

      - name: 🧹 Preparar ambiente local
        run: |
          echo "📁 Verificando arquivos para deploy..."
          [[ -f docker-compose.yml ]] || { echo "❌ docker-compose.yml não encontrado"; exit 1; }
          mkdir -p logs
          echo "🔧 Garantindo rede compartilhada ${DOCKER_NETWORK_NAME}"
          if ! docker network ls --filter name="^${DOCKER_NETWORK_NAME}$" --format '{{.Name}}' | grep -q "${DOCKER_NETWORK_NAME}"; then
            docker network create --driver overlay --attachable "${DOCKER_NETWORK_NAME}"
          fi

      - name: 🐳 Deploy Docker Stack
        run: |
          set -Eeuo pipefail
          echo "🚀 Deploy da stack ${STACK_NAME}"
          docker stack deploy -c docker-compose.yml "${STACK_NAME}"
          echo "✅ Stack enviada"

      - name: 🏥 Health Check
        run: |
          echo "⏳ Aguardando serviço ficar saudável"
          attempts=0
          until curl -fsS http://localhost:8087/actuator/health >/dev/null; do
            attempts=$((attempts+1))
            if [ $attempts -ge 15 ]; then
              echo "❌ Serviço não ficou saudável a tempo"
              docker service ls --filter name="${STACK_NAME}_" --format 'table {{.Name}}\t{{.Replicas}}'
              exit 1
            fi
            echo "⏳ Tentativa $attempts..."
            sleep 10
          done
          echo "✅ Health check OK"

  summary:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: 📊 Resumo
        run: |
          echo "## 🎯 Deploy resultados" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ needs.deploy-selfhosted.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Serviço: ${SERVICE_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- Stack: ${STACK_NAME}" >> $GITHUB_STEP_SUMMARY
