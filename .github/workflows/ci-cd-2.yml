name: "ðŸŽ¯ Resultados Backend - CI/CD Pipeline (Self-hosted Deploy)"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SERVICE_NAME: resultados
  STACK_NAME: conexao-resultados
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write
  contents: read

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
      keyvault_name: ${{ steps.check_secrets.outputs.keyvault_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "âœ… docker-compose.yml vÃ¡lido"

      - name: Security Validation
        run: |
          echo "ðŸ” Verificando senha hardcoded em docker-compose.yml..."
          if grep -nE "password\s*:\s*[^[:space:]]+" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external"; then
            echo "âŒ Encontrada senha potencialmente hardcoded"
            exit 1
          fi
          echo "âœ… Sem senhas hardcoded detectadas"

      - name: ðŸ”Ž Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID || secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_ENDPOINT: ${{ vars.AZURE_KEYVAULT_ENDPOINT || secrets.AZURE_KEYVAULT_ENDPOINT }}
          AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME || secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf 'âŒ GitHub Secrets obrigatÃ³rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "âœ… Identificadores Azure configurados"

          keyvault_name=""
          if [[ -n "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            keyvault_name=$(echo "$AZURE_KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net.*|\1|')
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            echo "keyvault_name=$keyvault_name" >> "$GITHUB_OUTPUT"
            echo "âœ… Usando Key Vault informado via endpoint (${keyvault_name})"
          elif [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            keyvault_name="$AZURE_KEYVAULT_NAME"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            echo "keyvault_name=$keyvault_name" >> "$GITHUB_OUTPUT"
            echo "âœ… Usando Key Vault informado via nome (${keyvault_name})"
          else
            echo "âŒ Nenhum Key Vault configurado para o serviÃ§o resultados"
            exit 1
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validation completed
        run: echo "âœ… ValidaÃ§Ã£o concluÃ­da - pipeline liberado para deploy"

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-backend-resultados]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: ðŸ” Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: âœ… Validar sessÃ£o Azure
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        run: |
          echo "ðŸ” Validando sessÃ£o Azure..."
          az account show >/dev/null 2>&1 || { echo "âŒ Falha na autenticaÃ§Ã£o Azure"; exit 1; }
          echo "âœ… Azure autenticado (subscription $(az account show --query id -o tsv))"

      - name: ðŸ”‘ Buscar segredos no Azure Key Vault
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        env:
          KEYVAULT_NAME: ${{ needs.validate-and-build.outputs.keyvault_endpoint }}
        run: |
          set -Eeuo pipefail
          if [[ -z "${KEYVAULT_NAME}" ]]; then
            echo "âŒ Nome do Key Vault nÃ£o definido"
            exit 1
          fi
          echo "ðŸ” Lendo segredos do Key Vault ${KEYVAULT_NAME}"
          SECRETS=(
            conexao-de-sorte-database-r2dbc-url
            conexao-de-sorte-database-jdbc-url
            conexao-de-sorte-database-username
            conexao-de-sorte-database-password
            conexao-de-sorte-redis-host
            conexao-de-sorte-redis-port
            conexao-de-sorte-redis-password
            conexao-de-sorte-redis-database
            conexao-de-sorte-jwt-secret
            conexao-de-sorte-jwt-issuer
            conexao-de-sorte-jwt-jwks-uri
            conexao-de-sorte-jwt-refresh-token-validity
            conexao-de-sorte-jwt-access-token-validity
            conexao-de-sorte-jwt-cleanup-interval
          )
          for secret_name in "${SECRETS[@]}"; do
            echo "ðŸ” Secret: ${secret_name}"
            secret_value=$(az keyvault secret show --vault-name "${KEYVAULT_NAME}" --name "${secret_name}" --query value -o tsv 2>/dev/null || true)
            if [[ -n "${secret_value}" ]]; then
              env_var=$(echo "${secret_name}" | tr '-' '_' | tr '[:lower:]' '[:upper:]')
              echo "${env_var}=${secret_value}" >> $GITHUB_ENV
              echo "::add-mask::${secret_value}"
            else
              echo "âš ï¸ Secret '${secret_name}' nÃ£o encontrado - mantendo deploy, porÃ©m verifique Key Vault"
            fi
          done
          echo "âœ… Segredos processados"

      - name: ðŸ—„ï¸ Garantir secrets do Docker Swarm
        run: |
          set -Eeuo pipefail
          ensure_secret() {
            local secret_name="$1"
            local value="$2"
            if [[ -z "$value" ]]; then
              echo "âŒ Valor nÃ£o fornecido para o secret $secret_name"
              exit 1
            fi
            if docker secret ls --format '{{.Name}}' | grep -q "^${secret_name}$"; then
              echo "â„¹ï¸ Secret ${secret_name} jÃ¡ existe, atualizando"
              docker secret rm "$secret_name" >/dev/null 2>&1 || true
            fi
            printf "%s" "$value" | docker secret create "$secret_name" - >/dev/null
            echo "âœ… Secret ${secret_name} disponÃ­vel"
          }
          ensure_secret "conexao-de-sorte-database-username" "${CONEXAO_DE_SORTE_DATABASE_USERNAME:-}"
          ensure_secret "conexao-de-sorte-database-password" "${CONEXAO_DE_SORTE_DATABASE_PASSWORD:-}"
          ensure_secret "conexao-de-sorte-database-r2dbc-url" "${CONEXAO_DE_SORTE_DATABASE_R2DBC_URL:-}"
          ensure_secret "conexao-de-sorte-database-jdbc-url" "${CONEXAO_DE_SORTE_DATABASE_JDBC_URL:-}"
          ensure_secret "conexao-de-sorte-redis-password" "${CONEXAO_DE_SORTE_REDIS_PASSWORD:-}"
          ensure_secret "conexao-de-sorte-jwt-secret" "${CONEXAO_DE_SORTE_JWT_SECRET:-}"

      - name: ðŸ§¹ Preparar ambiente local
        run: |
          echo "ðŸ“ Verificando arquivos para deploy..."
          [[ -f docker-compose.yml ]] || { echo "âŒ docker-compose.yml nÃ£o encontrado"; exit 1; }
          mkdir -p logs
          echo "ðŸ”§ Garantindo rede compartilhada ${DOCKER_NETWORK_NAME}"
          if ! docker network ls --filter name="^${DOCKER_NETWORK_NAME}$" --format '{{.Name}}' | grep -q "${DOCKER_NETWORK_NAME}"; then
            docker network create --driver overlay --attachable "${DOCKER_NETWORK_NAME}"
          fi

      - name: ðŸ³ Deploy Docker Stack
        run: |
          set -Eeuo pipefail
          echo "ðŸš€ Deploy da stack ${STACK_NAME}"
          docker stack deploy -c docker-compose.yml "${STACK_NAME}"
          echo "âœ… Stack enviada"

      - name: ðŸ¥ Health Check
        run: |
          echo "â³ Aguardando serviÃ§o ficar saudÃ¡vel"
          attempts=0
          until curl -fsS http://localhost:8087/actuator/health >/dev/null; do
            attempts=$((attempts+1))
            if [ $attempts -ge 15 ]; then
              echo "âŒ ServiÃ§o nÃ£o ficou saudÃ¡vel a tempo"
              docker service ls --filter name="${STACK_NAME}_" --format 'table {{.Name}}\t{{.Replicas}}'
              exit 1
            fi
            echo "â³ Tentativa $attempts..."
            sleep 10
          done
          echo "âœ… Health check OK"

  summary:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: ðŸ“Š Resumo
        run: |
          echo "## ðŸŽ¯ Deploy resultados" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ needs.deploy-selfhosted.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ServiÃ§o: ${SERVICE_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- Stack: ${STACK_NAME}" >> $GITHUB_STEP_SUMMARY
