name: "üéØ Resultados Backend ‚Äì CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Controle de concorr√™ncia para evitar execu√ß√µes simult√¢neas
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Vari√°veis de ambiente global
env:
  SERVICE_NAME: resultados-backend
  STACK_NAME: conexao-resultados
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write    # Necess√°rio para OIDC com Azure (azure/login@v2)
  contents: read     # Necess√°rio para checkout em jobs

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq curl zip unzip

      - name: Install SDKMAN! and Java 25 LTS
        run: |
          # Install SDKMAN!
          curl -s "https://get.sdkman.io" | bash
          source "$HOME/.sdkman/bin/sdkman-init.sh"

          # Install Java 25 LTS (Azul Zulu - OpenJDK)
          sdk install java 25-zulu
          sdk default java 25-zulu

          # Verify installation
          java -version
          javac -version

          # Setup environment for subsequent steps
          echo "SDKMAN_DIR=$HOME/.sdkman" >> $GITHUB_ENV
          echo "$HOME/.sdkman/bin" >> $GITHUB_PATH

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se n√£o h√° hardcoded passwords
          # Ignorar: 1) vari√°veis de ambiente ${}, 2) coment√°rios #, 3) secrets externos
          if grep -r "password.*:" docker-compose.yml pom.xml | grep -v "\${" | grep -v "#" | grep -v "external: true"; then
            # Verificar se as linhas encontradas s√£o realmente valores hardcoded e n√£o refer√™ncias
            hardcoded_lines=$(grep -r "password.*:" docker-compose.yml pom.xml | grep -v "\${" | grep -v "#" | grep -v "external: true")
            if echo "$hardcoded_lines" | grep -E ":[[:space:]]*['\"][^'\"]{8,}['\"]"; then
              echo "‚ùå Found potential hardcoded passwords"
              echo "$hardcoded_lines"
              exit 1
            else
              echo "‚úÖ No hardcoded passwords found (only external secret references)"
            fi
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

      - name: üîé Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '‚ùå GitHub Secrets obrigat√≥rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "‚úÖ Identificadores Azure configurados via secrets"

          # Key Vault √© opcional - verificar ENDPOINT ou NAME
          if [[ -n "${AZURE_KEYVAULT_ENDPOINT:-}" ]] || [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo '‚ÑπÔ∏è AZURE_KEYVAULT_ENDPOINT n√£o definido (usando endpoint padr√£o)'
          else
            echo '‚úÖ Endpoint customizado definido'
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validate Maven Project
        run: |
          # Setup SDKMAN! environment
          source "$HOME/.sdkman/bin/sdkman-init.sh"

          if [ -f "pom.xml" ]; then
            echo "‚úÖ Projeto Maven detectado"
            mvn validate
            echo "‚úÖ Maven project validation passed"
          else
            echo "‚ÑπÔ∏è Projeto n√£o-Maven (sem pom.xml)"
          fi

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'‚úÖ YAML v√°lido: {file_path}')
                  except Exception as e:
                      print(f'‚ùå Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: Validation completed
        run: |
          # Setup SDKMAN! environment for validation
          source "$HOME/.sdkman/bin/sdkman-init.sh"
          echo "‚úÖ Valida√ß√£o conclu√≠da - pronto para deploy"
          echo "üìã Java version check:"
          java -version

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-backend-resultados]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: üîê Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: üîí Security Validation - Port Exposure
        run: |
          # Verificar exposi√ß√£o de portas do Resultados
          if grep -E "^\s*-\s*[\"']?(8081|8082|8083):" docker-compose.yml; then
            echo "‚ö†Ô∏è WARNING: Resultados ports may be exposed - ensure firewall protection"
            echo "üîí Note: Current configuration works but consider overlay-only for maximum security"
          else
            echo "‚úÖ No ports exposed - maximum security (overlay network only)"
          fi

      - name: üîê Get secrets from Azure Key Vault (OIDC)
        id: get-secrets
        continue-on-error: true
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          set -Eeuo pipefail
          echo "üîê Buscando secrets essenciais do Resultados no Key Vault..."

          # Usar endpoint do Key Vault se dispon√≠vel, sen√£o usar nome
          KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ -n "$KEYVAULT_ENDPOINT" ]]; then
            # Extrair o nome do Key Vault do endpoint (formato: https://nome-do-keyvault.vault.azure.net/)
            KEYVAULT_NAME=$(echo "$KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net/.*|\1|')
            echo "üîç Usando Key Vault do endpoint: $KEYVAULT_NAME"
          else
            KEYVAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME }}"
            echo "üîç Usando Key Vault do nome: $KEYVAULT_NAME"
          fi

          # Verificar autentica√ß√£o Azure
          echo "üîç Verificando autentica√ß√£o Azure..."
          if ! az account show >/dev/null 2>&1; then
            echo "‚ùå Azure CLI n√£o autenticado - execute o login Azure OIDC primeiro"
            exit 1
          fi

          # Lista de secrets essenciais para o servi√ßo Resultados (apenas os que existem no Azure Key Vault)
          secrets_list="conexao-de-sorte-database-r2dbc-url,conexao-de-sorte-database-username,conexao-de-sorte-database-password,conexao-de-sorte-redis-host,conexao-de-sorte-redis-port,conexao-de-sorte-redis-password,conexao-de-sorte-redis-database,conexao-de-sorte-jwt-issuer,conexao-de-sorte-jwt-jwks-uri,conexao-de-sorte-server-port"

          IFS=',' read -ra SECRETS_ARRAY <<< "$secrets_list"
          essential_count=0
          
          for secret_name in "${SECRETS_ARRAY[@]}"; do
            echo "üîç Obtendo segredo: $secret_name"
            secret_value=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "$secret_name" --query 'value' -o tsv 2>/dev/null || echo "")
            
            if [[ -n "$secret_value" ]]; then
              echo "‚úÖ Segredo obtido: $secret_name"
              
              # Valida√ß√µes de seguran√ßa para senhas e secrets cr√≠ticos
              if [[ "$secret_name" == *"password"* || "$secret_name" == *"jwt-secret"* ]]; then
                # Validar tamanho m√≠nimo (m√≠nimo 8 caracteres)
                if [[ ${#secret_value} -lt 8 ]]; then
                  echo "‚ùå Secret $secret_name muito curto (m√≠nimo 8 caracteres)" >&2
                  exit 1
                fi
                # Validar que n√£o √© uma senha padr√£o/fraca
                if [[ "$secret_value" =~ ^(12345678|password|admin|root|teste|senha)$ ]]; then
                  echo "‚ùå Secret $secret_name usa valor padr√£o/inseguro" >&2
                  exit 1
                fi
              fi
              
              # Salvar com o nome original (com tra√ßos) para compatibilidade com o step de valida√ß√£o
              echo "${secret_name}=${secret_value}" >> $GITHUB_OUTPUT
              
              # Tamb√©m salvar como vari√°vel de ambiente para uso posterior
              var_name=$(echo "$secret_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
              echo "$var_name=$secret_value" >> "$GITHUB_ENV"
              echo "::add-mask::$secret_value"
              echo "‚úÖ $secret_name obtido e validado (len=${#secret_value}) => exportado como $var_name"
              essential_count=$((essential_count + 1))
            else
              echo "‚ö†Ô∏è Segredo n√£o encontrado: $secret_name"
            fi
          done

          echo "üìä Total de secrets essenciais obtidos: $essential_count/${#SECRETS_ARRAY[@]}"
          if [[ $essential_count -ge 10 ]]; then
            echo "‚úÖ Secrets suficientes e validados para deploy (m√≠nimo 10/15)"
          else
            echo "‚ùå Poucos secrets obtidos - deploy ser√° abortado"
            exit 1
          fi
        shell: /usr/bin/bash -e {0}

      - name: üîê Criar Docker Secrets from Azure Key Vault
        if: always() && (steps.get-secrets.outcome == 'success' || steps.get-secrets.outcome == 'failure')
        run: |
          # N√£o usar set -e para permitir continuar mesmo com erros individuais
          echo "üîê Criando Docker Secrets a partir dos valores do Azure Key Vault..."
          
          # Verificar status do step anterior
          echo "üìä Status do step get-secrets: ${{ steps.get-secrets.outcome }}"
          if [[ "${{ steps.get-secrets.outcome }}" != "success" ]]; then
            echo "‚ö†Ô∏è Step anterior falhou ou teve problemas - tentando continuar mesmo assim..."
          fi
          
          # Fun√ß√£o para obter secret do step anterior ou vari√°vel de ambiente
          get_secret_value() {
            local secret_name="$1"
            local var_name=$(echo "$secret_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
            
            # Tentar vari√°vel de ambiente primeiro (mais confi√°vel)
            if [[ -n "${!var_name:-}" ]]; then
              echo "${!var_name}"
              return 0
            fi
            
            # Se n√£o encontrar na vari√°vel de ambiente, tentar buscar do step anterior
            local step_output_var="${secret_name//-/_}"
            if [[ -n "${!step_output_var:-}" ]]; then
              echo "${!step_output_var}"
              return 0
            fi
            
            # Retornar vazio se n√£o encontrar (n√£o usar return 1 para evitar trigger do trap)
            echo ""
            return 0
          }
          
          # Fun√ß√£o para tratamento de erros
          handle_error() {
            echo "‚ùå Erro na linha $1: $2"
            # N√£o sair, apenas registrar o erro
          }
          
          # Configurar trap para capturar erros
          trap 'handle_error $LINENO "$BASH_COMMAND"' ERR
          
          # Debug: Verificar vari√°veis de ambiente dispon√≠veis
          echo "üìã Verificando vari√°veis de ambiente dispon√≠veis..."
          echo "üîç Buscando por vari√°veis CONEXAO_DE_SORTE..."
          env | grep -E "CONEXAO_DE_SORTE_" | sed 's/=.*$/=[REDACTED]/' || echo "‚ö†Ô∏è Nenhuma vari√°vel CONEXAO_DE_SORTE encontrada"
          
          # Debug: Verificar step outputs dispon√≠veis
          echo "üîç Verificando step outputs dispon√≠veis..."
          echo "Step outputs do get-secrets:"
          echo "- conexao-de-sorte-database-r2dbc-url: $([ -n "${CONEXAO_DE_SORTE_DATABASE_R2DBC_URL:-}" ] && echo "DEFINIDO" || echo "VAZIO")"
          echo "- conexao-de-sorte-database-username: $([ -n "${CONEXAO_DE_SORTE_DATABASE_USERNAME:-}" ] && echo "DEFINIDO" || echo "VAZIO")"
          echo "- conexao-de-sorte-database-password: $([ -n "${CONEXAO_DE_SORTE_DATABASE_PASSWORD:-}" ] && echo "DEFINIDO" || echo "VAZIO")"
          
          # Verificar se as vari√°veis do Azure Key Vault foram carregadas
          echo "üîç Verificando se secrets do Azure Key Vault foram carregados..."
          if [[ -z "${CONEXAO_DE_SORTE_DATABASE_R2DBC_URL:-}" ]]; then
            echo "‚ö†Ô∏è CONEXAO_DE_SORTE_DATABASE_R2DBC_URL n√£o est√° definido"
          else
            echo "‚úÖ CONEXAO_DE_SORTE_DATABASE_R2DBC_URL est√° definido (tamanho: ${#CONEXAO_DE_SORTE_DATABASE_R2DBC_URL} caracteres)"
          fi

          # Lista unificada de secrets para Docker Swarm (deve ser id√™ntica ao step anterior)
          secrets_list="conexao-de-sorte-database-r2dbc-url,conexao-de-sorte-database-username,conexao-de-sorte-database-password,conexao-de-sorte-redis-host,conexao-de-sorte-redis-port,conexao-de-sorte-redis-password,conexao-de-sorte-redis-database,conexao-de-sorte-jwt-issuer,conexao-de-sorte-jwt-jwks-uri,conexao-de-sorte-server-port"

          IFS=',' read -ra SECRETS_ARRAY <<< "$secrets_list"
          created_secrets=0
          
          # Inicializar contador de forma segura
          export created_secrets

          # Verificar se estamos em um ambiente Docker Swarm
          echo "üîç Verificando status do Docker Swarm..."
          if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
            echo "‚ö†Ô∏è Docker Swarm n√£o est√° ativo - tentando inicializar..."
            # Tentar inicializar como manager
            if docker swarm init --advertise-addr 127.0.0.1 2>/dev/null; then
              echo "‚úÖ Docker Swarm inicializado com sucesso"
              sleep 3
            else
              echo "‚ö†Ô∏è N√£o foi poss√≠vel inicializar Docker Swarm - tentando como worker..."
              # Se j√° houver um swarm, este comando falhar√°, mas n√£o √© cr√≠tico
              docker swarm init --advertise-addr 127.0.0.1 --force-new-cluster 2>/dev/null || echo "‚ö†Ô∏è Docker Swarm pode j√° estar inicializado ou n√£o √© poss√≠vel"
              sleep 2
            fi
          else
            echo "‚úÖ Docker Swarm j√° est√° ativo"
          fi

          for secret_name in "${SECRETS_ARRAY[@]}"; do
            echo "üìã Processando secret: $secret_name"
            
            # Obter valor do secret usando a fun√ß√£o
            secret_value=$(get_secret_value "$secret_name")
            
            if [[ -n "$secret_value" ]]; then
                echo "‚úÖ Secret $secret_name encontrado, prosseguindo com cria√ß√£o do Docker Secret"
                echo "üîê Criando Docker Secret: $secret_name"
            else
                echo "‚ö†Ô∏è Secret $secret_name n√£o encontrado no Azure Key Vault, pulando..."
                continue
            fi
              
              # Validar tamanho do valor
              if [[ ${#secret_value} -lt 1 ]]; then
                echo "‚ö†Ô∏è Secret $secret_name tem valor vazio - pulando..."
                continue
              fi
              
              # Limitar tamanho m√°ximo (Docker tem limite de 500KB)
              if [[ ${#secret_value} -gt 500000 ]]; then
                echo "‚ö†Ô∏è Secret $secret_name muito grande (${#secret_value} bytes) - pulando..."
                continue
              fi

              # Remover secret existente se houver (ignorar erros)
              if docker secret inspect "$secret_name" >/dev/null 2>&1; then
                echo "üóëÔ∏è Removendo secret existente: $secret_name"
                if docker secret rm "$secret_name" 2>/dev/null; then
                  echo "‚úÖ Secret removido com sucesso"
                else
                  echo "‚ö†Ô∏è N√£o foi poss√≠vel remover secret existente (pode estar em uso), verificando se j√° existe..."
                  # Verifica se o secret j√° existe e est√° funcionando
                  if docker secret inspect "$secret_name" >/dev/null 2>&1; then
                    echo "‚úÖ Secret $secret_name j√° existe e est√° funcionando, pulando cria√ß√£o"
                    created_secrets=$((created_secrets + 1))
                    continue
                  fi
                fi
                sleep 2
              fi

              # Criar novo secret com tratamento de erro
              echo "üîê Criando novo secret: $secret_name"
              
              # Tentar criar o secret com timeout e retry
              max_retries=3
              retry_count=0
              secret_created=false
              
              while [[ $retry_count -lt $max_retries ]] && [[ "$secret_created" == "false" ]]; do
                if echo -n "$secret_value" | docker secret create "$secret_name" - 2>&1; then
                echo "‚úÖ Docker Secret criado: $secret_name"
                created_secrets=$((created_secrets + 1))
                secret_created=true
              else
                # Verifica se o erro √© porque o secret j√° existe
                if docker secret inspect "$secret_name" >/dev/null 2>&1; then
                  echo "‚úÖ Secret $secret_name j√° existe e est√° funcionando"
                  created_secrets=$((created_secrets + 1))
                  secret_created=true
                else
                  retry_count=$((retry_count + 1))
                  if [[ $retry_count -lt $max_retries ]]; then
                    echo "‚ö†Ô∏è Tentativa $retry_count falhou, tentando novamente em 2 segundos..."
                    sleep 2
                  else
                    echo "‚ùå Falha ao criar secret ap√≥s $max_retries tentativas: $secret_name"
                    echo "‚ö†Ô∏è Verificando se o secret foi criado mesmo assim..."
                    if docker secret inspect "$secret_name" >/dev/null 2>&1; then
                      echo "‚úÖ Secret $secret_name existe apesar do erro - continuando..."
                      created_secrets=$((created_secrets + 1))
                      secret_created=true
                    else
                      echo "‚ùå Secret $secret_name realmente n√£o foi criado"
                    fi
                  fi
                fi
              fi
              done
              
              if [[ "$secret_created" == "false" ]]; then
                echo "‚ö†Ô∏è Continuando com os pr√≥ximos secrets..."
              else
                echo "‚úÖ Secret $secret_name processado com sucesso"
              fi
          done

          echo "‚úÖ Total de Docker Secrets criados/processados: $created_secrets/10 (apenas os que existem no Azure Key Vault)"
          
          # Debug do contador
          echo "üìà Debug: Valor final do contador: $created_secrets"
          
          # Listar todos os secrets dispon√≠veis no Docker
          echo "üìã Secrets dispon√≠veis no Docker Swarm:"
          docker secret ls || echo "‚ö†Ô∏è N√£o foi poss√≠vel listar secrets"
          
          # Verificar se os secrets cr√≠ticos foram criados
          echo "üîç Verificando secrets cr√≠ticos:"
          critical_missing=0
          for secret_name in "${SECRETS_ARRAY[@]}"; do
            if docker secret inspect "$secret_name" >/dev/null 2>&1; then
              echo "‚úÖ Secret cr√≠tico encontrado: $secret_name"
            else
              echo "‚ùå Secret cr√≠tico ausente: $secret_name"
              critical_missing=$((critical_missing + 1))
            fi
          done
          
          if [[ $created_secrets -lt 7 ]]; then
            echo "‚ùå Poucos secrets criados - deploy pode falhar (m√≠nimo 7/10 secrets cr√≠ticos)"
            echo "‚ùå Secrets cr√≠ticos ausentes: $critical_missing"
            echo "üîç Secrets necess√°rios: database-r2dbc-url, database-username, database-password, redis-*, jwt-*, server-port"
            exit 1
          else
            echo "‚úÖ Sucesso: M√≠nimo de 7 secrets cr√≠ticos foi atingido ($created_secrets/10)"
          fi

      - name: üåê Preparar rede overlay compartilhada
        env:
          NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          set -euo pipefail
          echo "üîç Verificando rede overlay: $NETWORK_NAME"

          if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
            echo "üèóÔ∏è Criando rede overlay compartilhada: $NETWORK_NAME"
            docker network create \
              --driver overlay \
              --attachable \
              --subnet=10.10.0.0/16 \
              --gateway=10.10.0.1 \
              "${NETWORK_NAME}"
            echo "‚úÖ Rede overlay criada: $NETWORK_NAME"
          else
            echo "‚úÖ Rede overlay j√° existe: $NETWORK_NAME"
          fi

      - name: üßπ Cleanup anterior (Resultados)
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          set -euo pipefail
          echo "üßπ Iniciando limpeza de recursos anteriores..."

          # 1. Graceful shutdown: scale services to 0 replicas
          if docker service ls --filter name="$STACK_NAME" --format '{{.Name}}' | grep -q "^$STACK_NAME"; then
            echo "üîÑ Scaling down servi√ßos do stack $STACK_NAME..."
            for service in $(docker service ls --filter name="$STACK_NAME" --format '{{.Name}}'); do
              echo "  - Scaling down: $service"
              docker service scale "$service=0" >/dev/null 2>&1 || true
            done
            sleep 10
          fi

          # 2. Remove stack
          if docker stack ls --format '{{.Name}}' | grep -q "^$STACK_NAME\$"; then
            echo "üóÑÔ∏è Removendo stack: $STACK_NAME"
            docker stack rm "$STACK_NAME"
            sleep 15
          fi

          # 3. Clean orphan containers
          echo "üßπ Limpando containers √≥rf√£os relacionados ao Resultados..."
          orphan_containers=$(docker ps -a --filter name="*resultados*" --format '{{.ID}} {{.Names}}' | grep -E "(resultados|$STACK_NAME)" || true)
          if [[ -n "$orphan_containers" ]]; then
            echo "$orphan_containers" | while read container_id container_name; do
              if [[ -n "$container_id" ]]; then
                echo "  üóëÔ∏è Removendo container √≥rf√£o: $container_name ($container_id)"
                docker stop "$container_id" >/dev/null 2>&1 || true
                docker rm "$container_id" >/dev/null 2>&1 || true
              fi
            done
          fi

          # 4. Image cleanup (keep 3 recent versions)
          echo "üßπ Limpando imagens antigas do Resultados (mantendo 3 vers√µes recentes)..."
          old_images=$(docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep -E "(resultados|ghcr.io.*resultados)" | tail -n +4 || true)
          if [[ -n "$old_images" ]]; then
            echo "$old_images" | while read image_id image_tag; do
              if [[ -n "$image_id" && "$image_tag" != *"<none>"* ]]; then
                echo "  üóëÔ∏è Removendo imagem antiga: $image_tag ($image_id)"
                docker rmi "$image_id" >/dev/null 2>&1 || true
              fi
            done
          fi

          echo "‚úÖ Limpeza conclu√≠da"

      - name: üöÄ Deploy Resultados Stack (Swarm-Only)
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          COMPOSE_FILE: docker-compose.yml
          # Environment variables from Key Vault (m√©todo manual - padr√£o Gateway)
          DATABASE_R2DBC_URL: ${{ env.CONEXAO_DE_SORTE_DATABASE_R2DBC_URL }}
          DATABASE_USERNAME: ${{ env.CONEXAO_DE_SORTE_DATABASE_USERNAME }}
          DATABASE_PASSWORD: ${{ env.CONEXAO_DE_SORTE_DATABASE_PASSWORD }}
          REDIS_HOST: ${{ env.CONEXAO_DE_SORTE_REDIS_HOST }}
          REDIS_PORT: ${{ env.CONEXAO_DE_SORTE_REDIS_PORT }}
          REDIS_PASSWORD: ${{ env.CONEXAO_DE_SORTE_REDIS_PASSWORD }}
          REDIS_DATABASE: ${{ env.CONEXAO_DE_SORTE_REDIS_DATABASE }}
          RABBITMQ_HOST: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_HOST }}
          RABBITMQ_PORT: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_PORT }}
          RABBITMQ_USERNAME: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_USERNAME }}
          RABBITMQ_PASSWORD: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_PASSWORD }}
          RABBITMQ_VHOST: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_VHOST }}
          JWT_SECRET: ${{ env.CONEXAO_DE_SORTE_JWT_SECRET }}
          JWT_ISSUER: ${{ env.CONEXAO_DE_SORTE_JWT_ISSUER }}
          SERVER_PORT: ${{ env.CONEXAO_DE_SORTE_SERVER_PORT }}
        run: |
          echo "üöÄ Iniciando deploy do Resultados com Docker Swarm..."

          echo "üèóÔ∏è Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "‚è∞ Aguardando estabiliza√ß√£o dos servi√ßos Resultados..."
          sleep 35

      - name: üîç Healthcheck Resultados
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          echo "üîç Validando sa√∫de do Resultados..."

          timeout=200
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            RESULTADOS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_resultados" | head -1)

            if [ -n "$RESULTADOS_CONTAINER" ]; then
              echo "üîç Testando health check do Resultados... ($elapsed/$timeout segundos)"

              # Check 1: Process validation
              if docker exec "$RESULTADOS_CONTAINER" ps aux 2>/dev/null | grep -q "[j]ava\|[s]pring"; then
                echo "‚úÖ Resultados health check passed (process validation)"
                health_passed=true
                break
              fi

              # Check 2: Log validation
              if docker logs "$RESULTADOS_CONTAINER" 2>/dev/null | grep -q "Started.*Application\|Tomcat started\|Started ResultadosApplication"; then
                echo "‚úÖ Resultados health check passed (logs validation)"
                health_passed=true
                break
              fi

              echo "‚è≥ Resultados ainda n√£o est√° pronto... ($elapsed/$timeout segundos)"
            else
              echo "‚è≥ Container Resultados ainda n√£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "‚ö†Ô∏è Resultados health check n√£o passou em $timeout segundos"
            echo "üîç Verificando logs finais do Resultados..."
            if [ -n "$RESULTADOS_CONTAINER" ]; then
              echo "--- √öltimos 30 logs do Resultados ---"
              docker logs "$RESULTADOS_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "üí° Nota: Resultados pode estar funcionando mesmo com health check parcial"
            exit 1
          else
            echo "‚úÖ Resultados health check conclu√≠do com sucesso!"
          fi

      - name: üîó Connectivity Validation
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          DOCKER_NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          echo "üîó Validando conectividade do Resultados..."

          if docker service ls | grep -q "${STACK_NAME}_resultados"; then
            echo "‚úÖ Servi√ßo Resultados encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo Resultados n√£o encontrado no Swarm"
            exit 1
          fi

          if docker network inspect "$DOCKER_NETWORK_NAME" | grep -q resultados; then
            echo "‚úÖ Resultados conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è Resultados pode n√£o estar na rede overlay correta"
          fi

          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: üè• Validar Health Monitor (Traefik)
        env:
          HEALTH_MONITOR_URL: https://traefik.conexaodesorte.com.br/health/service/resultados
        run: |
          set -euo pipefail
          timeout=300
          interval=10
          elapsed=0
          last_response=""

          while [ $elapsed -lt $timeout ]; do
            echo "üîé Consultando Health Monitor (${elapsed}/${timeout}s)..."
            response=$(curl -sf --max-time 10 "$HEALTH_MONITOR_URL" 2>/dev/null || true)
            last_response="$response"

            if [[ -n "$response" ]]; then
              status=$(echo "$response" | python3 -c 'import json,sys; data=json.load(sys.stdin); print(data.get("status", ""))' 2>/dev/null || true)
              status=${status//$'\n'/}
              echo "üìä Status reportado pelo monitor: ${status:-indefinido}"

              if [[ "$status" == "healthy" ]]; then
                echo "‚úÖ Traefik confirmou Resultados como healthy"
                exit 0
              fi
            else
              echo "‚ö†Ô∏è Health Monitor sem resposta (tentativa atual)"
            fi

            sleep "$interval"
            elapsed=$((elapsed + interval))
          done

          echo "‚ùå Health Monitor nao confirmou Resultados como healthy apos ${timeout}s"
          echo "üìù Ultima resposta recebida: ${last_response:-<sem resposta>}"
          exit 1

      - name: üßº Limpeza de recursos no servidor
        if: success()
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          set -euo pipefail
          before_usage=$(mktemp)
          after_usage=$(mktemp)
          docker system df > "$before_usage"
          echo "üßπ Removendo containers parados (‚â•12h)..."
          docker container prune -f --filter "until=12h"
          echo "üßπ Removendo imagens n√£o utilizadas (‚â•7d)..."
          docker image prune -f --filter "until=168h"
          echo "üßπ Removendo caches de build antigos (‚â•7d)..."
          docker builder prune -f --filter "until=168h" || true
          docker system df > "$after_usage"
          echo "üì¶ Uso de recursos ap√≥s limpeza:"
          cat "$after_usage"
          {
            echo "## Limpeza de recursos no servidor"
            echo ""
            echo "### Uso antes"
            sed 's/^/    /' "$before_usage"
            echo ""
            echo "### Uso depois"
            sed 's/^/    /' "$after_usage"
          } >> "$GITHUB_STEP_SUMMARY"
          rm -f "$before_usage" "$after_usage"
