name: "üéØ Resultados ‚Äì CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: "Destino do deploy"
        required: false
        default: "production"
        type: choice
        options: [ staging, production ]

# ----------------------------------------------------------------------
# PAR√ÇMETROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: resultados
  TZ: America/Sao_Paulo

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

# ----------------------------------------------------------------------
# JOB 1 ‚ñ∏ VALIDA√á√ÉO DO WORKSPACE
# ----------------------------------------------------------------------

jobs:
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: "Guard: proibir r2dbc:h2 fora de testes"
        shell: bash
        run: |
          set -euo pipefail
          FOUND=$(grep -R --line-number --include='*.yml' --include='*.yaml' --include='*.properties' "r2dbc:h2" src || true)
          if echo "$FOUND" | grep -v "src/test/" | grep -q "r2dbc:h2"; then
            echo "‚ùå r2dbc:h2 encontrado fora de src/test" >&2
            echo "$FOUND" >&2
            exit 1
          fi

      - name: "Guard: depend√™ncia H2 n√£o‚Äëtest"
        shell: bash
        run: |
          ./mvnw -q dependency:list -DincludeScope=compile -DoutputFile=deps.txt
          if grep -E "com.h2database:h2|io.r2dbc:r2dbc-h2" deps.txt; then
            echo "‚ùå H2 presente em scope de produ√ß√£o" >&2
            exit 1
          fi

# ----------------------------------------------------------------------
# JOB 2 ‚ñ∏ BUILD + TEST + SAST/SCA
# ----------------------------------------------------------------------

  build-test-scan:
    needs: validate-environment
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java 24 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "24"
          cache: maven

      - name: Build + Test + Package
        run: ./mvnw package

      - name: Upload JAR artefact
        uses: actions/upload-artifact@v4
        with:
          name: resultados-jar
          path: target/resultados-*.jar
          retention-days: 1

# ----------------------------------------------------------------------
# JOB 3 ‚ñ∏ BUILD DA IMAGEM + PUSH GHCR
# ----------------------------------------------------------------------

  build-image:
    needs: build-test-scan
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      image: ${{ steps.build.outputs.image }}
    permissions:
      packages: write
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Download JAR artefact
        uses: actions/download-artifact@v4
        with:
          name: resultados-jar
          path: target

      # ‚îÄ‚îÄ‚îÄ OIDC login no Azure para acessar Key Vault ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false

      - name: Extrair secrets resultados (Key Vault) ‚ñ∂ arquivos tempor√°rios
        id: secrets
        shell: bash
        run: |
          set -euo pipefail
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ "$VAULT_ENDPOINT" =~ https://([^.]+)\.vault\.azure\.net ]]; then
            VAULT="${BASH_REMATCH[1]}"
          else
            echo "ERROR: Invalid AZURE_KEYVAULT_ENDPOINT format: $VAULT_ENDPOINT" >&2
            exit 1
          fi
          
          echo "Loading secrets from Azure Key Vault: $VAULT" >&2
          
          # Resultados secrets
          REDIS_PASS=$(az keyvault secret show --vault-name "$VAULT" --name conexao-de-sorte-redis-password --query value -o tsv 2>/dev/null)
          JWT_SECRET=$(az keyvault secret show --vault-name "$VAULT" --name conexao-de-sorte-jwt-secret --query value -o tsv 2>/dev/null)
          
          # Validar secrets obrigat√≥rios
          if [ -z "$REDIS_PASS" ] || [ -z "$JWT_SECRET" ]; then
            echo "ERROR: Required Resultados secrets not found in Azure Key Vault $VAULT" >&2
            exit 1
          fi
          
          # Mascarar secrets nos logs
          echo "::add-mask::$REDIS_PASS"
          echo "::add-mask::$JWT_SECRET"
          
          # Salvar em arquivos tempor√°rios
          printf "%s" "$REDIS_PASS" > redis_pass.txt
          printf "%s" "$JWT_SECRET" > jwt_secret.txt

      # ‚îÄ‚îÄ‚îÄ Login no GHCR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push Resultados
        id: build
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE=ghcr.io/$REPO_LOWER/resultados:${{ github.sha }}
          
          # Build com secrets
          docker buildx build \
            --tag "$IMAGE" \
            --push \
            --provenance=true \
            --sbom=true \
            --secret id=redis_password,src=redis_pass.txt \
            --secret id=jwt_secret,src=jwt_secret.txt \
            --file Dockerfile .
          
          # Limpar arquivos de secrets
          rm -f redis_pass.txt jwt_secret.txt
          
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"

# ----------------------------------------------------------------------
# JOB 4 ‚ñ∏ DEPLOY SELF‚ÄëHOSTED (Docker Swarm + secrets)
# ----------------------------------------------------------------------

  deploy-selfhosted:
    needs: build-image
    runs-on: [ self-hosted, Linux, X64, conexao, conexao-de-sorte-backend-resultados ]
    timeout-minutes: 30
    if: |
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production'))
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Login GHCR (Self-hosted)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull imagem do GHCR
        run: docker pull "${{ needs.build-image.outputs.image }}"

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false

      - name: Carregar todos os segredos do Azure Key Vault
        shell: bash
        run: |
          set -euo pipefail
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ "$VAULT_ENDPOINT" =~ https://([^.]+)\.vault\.azure\.net ]]; then
            VAULT="${BASH_REMATCH[1]}"
          else
            echo "ERROR: Invalid AZURE_KEYVAULT_ENDPOINT format: $VAULT_ENDPOINT" >&2
            exit 1
          fi
          
          echo "üîê Loading all secrets from Azure Key Vault: $VAULT" >&2
          
          # Fun√ß√£o para obter secret com fallback gracioso
          get_secret() {
            local secret_name="$1"
            local fallback_value="$2"
            local secret_value
            
            secret_value=$(az keyvault secret show --vault-name "$VAULT" --name "$secret_name" --query value -o tsv 2>/dev/null || echo "")
            if [ -z "$secret_value" ]; then
              if [ -n "$fallback_value" ]; then
                echo "‚ö†Ô∏è Secret $secret_name not found, using fallback" >&2
                echo "$fallback_value"
              else
                echo "‚ùå Secret $secret_name not found and no fallback provided" >&2
                return 1
              fi
            else
              echo "‚úÖ Secret $secret_name loaded successfully" >&2
              echo "$secret_value"
            fi
          }
          
          # Carregar segredos com fallbacks seguros
          REDIS_HOST=$(get_secret "conexao-de-sorte-redis-host" "localhost")
          REDIS_PORT=$(get_secret "conexao-de-sorte-redis-port" "6379")
          REDIS_PASSWORD=$(get_secret "conexao-de-sorte-redis-password" "")
          REDIS_DATABASE=$(get_secret "conexao-de-sorte-redis-database" "9")
          
          JWT_SECRET=$(get_secret "conexao-de-sorte-jwt-secret" "")
          JWT_ISSUER=$(get_secret "conexao-de-sorte-jwt-issuer" "https://conexaodesorte.com.br")
          
          CORS_ALLOWED_ORIGINS=$(get_secret "conexao-de-sorte-cors-allowed-origins" "https://conexaodesorte.com.br")
          CORS_ALLOW_CREDENTIALS=$(get_secret "conexao-de-sorte-cors-allow-credentials" "false")
          
          # Criar/atualizar Docker secrets
          printf "%s" "$REDIS_PASSWORD" | docker secret create resultados_redis_password - 2>/dev/null || docker secret update resultados_redis_password -
          printf "%s" "$JWT_SECRET" | docker secret create resultados_jwt_secret - 2>/dev/null || docker secret update resultados_jwt_secret -
          
          # Salvar vari√°veis de ambiente para o pr√≥ximo step
          echo "REDIS_HOST=$REDIS_HOST" >> $GITHUB_ENV
          echo "REDIS_PORT=$REDIS_PORT" >> $GITHUB_ENV
          echo "REDIS_DATABASE=$REDIS_DATABASE" >> $GITHUB_ENV
          echo "JWT_ISSUER=$JWT_ISSUER" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=$CORS_ALLOWED_ORIGINS" >> $GITHUB_ENV
          echo "CORS_ALLOW_CREDENTIALS=$CORS_ALLOW_CREDENTIALS" >> $GITHUB_ENV

      - name: üßπ Cleanup existing deployment
        run: |
          # Remove stack existente se houver
          docker stack rm conexao-resultados 2>/dev/null || true
          
          # Aguardar limpeza completa
          echo "‚è≥ Aguardando limpeza completa..."
          sleep 15
          
          # Limpar containers √≥rf√£os do servi√ßo resultados
          docker container ls -q --filter "name=resultados" | xargs -r docker stop
          docker container ls -aq --filter "name=resultados" | xargs -r docker rm
          
          echo "‚úÖ Limpeza conclu√≠da"

      - name: Deploy via docker stack
        run: |
          STACK=conexao-resultados
          IMAGE="${{ needs.build-image.outputs.image }}"
          
          # Criar rede se n√£o existir
          docker network create --driver overlay conexao-network 2>/dev/null || true
          
          cat <<EOF | docker stack deploy --with-registry-auth -c - $STACK
          version: "3.9"
          services:
            resultados:
              image: $IMAGE
              secrets:
                - resultados_redis_password
                - resultados_jwt_secret
              environment:
                # Spring Configuration
                SPRING_PROFILES_ACTIVE: prod,azure
                TZ: America/Sao_Paulo
                SERVER_PORT: 8080
                
                # Redis Configuration
                SPRING_DATA_REDIS_HOST: "$REDIS_HOST"
                SPRING_DATA_REDIS_PORT: "$REDIS_PORT"
                SPRING_DATA_REDIS_DATABASE: "$REDIS_DATABASE"
                
                # JWT Configuration
                JWT_ISSUER: "$JWT_ISSUER"
                
                # CORS Configuration
                CORS_ALLOWED_ORIGINS: "$CORS_ALLOWED_ORIGINS"
                CORS_ALLOW_CREDENTIALS: "$CORS_ALLOW_CREDENTIALS"
                
                # Azure Configuration
                AZURE_CLIENT_ID: "${{ secrets.AZURE_CLIENT_ID }}"
                AZURE_TENANT_ID: "${{ secrets.AZURE_TENANT_ID }}"
                AZURE_KEYVAULT_ENDPOINT: "${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
                AZURE_KEYVAULT_ENABLED: "true"
                
              deploy:
                restart_policy:
                  condition: any
                  delay: 30s
                  max_attempts: 2
                  window: 120s
                replicas: 1
                resources:
                  limits:
                    memory: 512M
                  reservations:
                    memory: 256M
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
              networks:
                - conexao-network
              labels:
                - "traefik.enable=true"
                - "traefik.http.routers.resultados.rule=Host(\`resultados.conexaodesorte.com.br\`)"
                - "traefik.http.routers.resultados.tls.certresolver=letsencrypt"
                - "traefik.http.services.resultados.loadbalancer.server.port=8080"
          
          secrets:
            resultados_redis_password:
              external: true
            resultados_jwt_secret:
              external: true
          
          networks:
            conexao-network:
              external: true
          EOF

      - name: Aguardar Resultados estar pronto
        run: |
          echo "‚è≥ Aguardando Resultados ficar pronto..."
          TIMEOUT=180
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if docker service ls | grep -q "resultados.*1/1"; then
              echo "‚úÖ Resultados est√° pronto!"
              break
            fi
            echo "‚è≥ Aguardando readiness... ($ELAPSED/$TIMEOUT segundos)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå Resultados n√£o ficou pronto em $TIMEOUT segundos"
            echo "üìã Status dos servi√ßos:"
            docker service ls | grep resultados || true
            echo "üìã Logs do Resultados:"
            docker service logs conexao-resultados_resultados --tail 50 || true
            exit 1
          fi

      - name: Health‚Äëcheck Resultados
        run: |
          echo "üîç Verificando sa√∫de do Resultados..."
          docker service ls | grep resultados
          
          # Teste do endpoint de health
          SERVICE_CONTAINER=$(docker ps --filter "name=resultados" --format "{{.Names}}" | head -1 || echo "")
          if [ -n "$SERVICE_CONTAINER" ]; then
            echo "üåê Testando health endpoint..."
            docker exec "$SERVICE_CONTAINER" curl -f http://localhost:8080/actuator/health 2>/dev/null && echo "‚úÖ Resultados health OK" || echo "‚ö†Ô∏è Resultados health test failed"
          fi
          
          echo "üéâ Resultados microservice deployment completed successfully!"
          echo "üåê API: https://resultados.conexaodesorte.com.br"

# ----------------------------------------------------------------------
# JOB 5 ‚ñ∏ NOTIFY
# ----------------------------------------------------------------------

  notify:
    if: always()
    runs-on: ubuntu-latest
    needs: [ build-test-scan, deploy-selfhosted ]
    steps:
      - name: Slack notify
        env:
          WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          RESULT: ${{ needs.deploy-selfhosted.result }}
        shell: bash
        run: |
          if [ -z "$WEBHOOK" ]; then
            echo "‚ÑπÔ∏è Slack webhook n√£o configurado; etapa ignorada" && exit 0
          fi
          COLOR=good && [ "$RESULT" != "success" ] && COLOR=danger
          curl -X POST -H 'Content-type: application/json' \
               --data "{\"text\":\"Resultados ‚Äì $RESULT\",\"attachments\":[{\"color\":\"$COLOR\"}]}" \
               "$WEBHOOK"
