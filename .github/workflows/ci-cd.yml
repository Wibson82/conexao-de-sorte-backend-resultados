name: "ðŸŽ¯ Resultados Backend â€“ CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Controle de concorrÃªncia para evitar execuÃ§Ãµes simultÃ¢neas
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# VariÃ¡veis de ambiente global
env:
  SERVICE_NAME: resultados-backend
  STACK_NAME: conexao-resultados
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write    # NecessÃ¡rio para OIDC com Azure (azure/login@v2)
  contents: read     # NecessÃ¡rio para checkout em jobs

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq curl zip unzip

      - name: Install SDKMAN! and Java 25 LTS
        run: |
          # Install SDKMAN!
          curl -s "https://get.sdkman.io" | bash
          source "$HOME/.sdkman/bin/sdkman-init.sh"

          # Install Java 25 LTS (Azul Zulu - OpenJDK)
          sdk install java 25-zulu
          sdk default java 25-zulu

          # Verify installation
          java -version
          javac -version

          # Setup environment for subsequent steps
          echo "SDKMAN_DIR=$HOME/.sdkman" >> $GITHUB_ENV
          echo "$HOME/.sdkman/bin" >> $GITHUB_PATH

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "âœ… Docker Compose syntax is valid"

      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se nÃ£o hÃ¡ hardcoded passwords
          if grep -r "password.*:" docker-compose.yml pom.xml | grep -v "\${" | grep -v "#" | grep -v "external:"; then
            echo "âŒ Found potential hardcoded passwords"
            exit 1
          else
            echo "âœ… No hardcoded passwords found"
          fi

      - name: ðŸ”Ž Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf 'âŒ GitHub Secrets obrigatÃ³rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "âœ… Identificadores Azure configurados via secrets"

          # Key Vault Ã© opcional
          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo 'â„¹ï¸ AZURE_KEYVAULT_ENDPOINT nÃ£o definido (usando endpoint padrÃ£o)'
          else
            echo 'âœ… Endpoint customizado definido'
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validate Maven Project
        run: |
          # Setup SDKMAN! environment
          source "$HOME/.sdkman/bin/sdkman-init.sh"

          if [ -f "pom.xml" ]; then
            echo "âœ… Projeto Maven detectado"
            mvn validate
            echo "âœ… Maven project validation passed"
          else
            echo "â„¹ï¸ Projeto nÃ£o-Maven (sem pom.xml)"
          fi

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'âœ… YAML vÃ¡lido: {file_path}')
                  except Exception as e:
                      print(f'âŒ Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: Validation completed
        run: |
          # Setup SDKMAN! environment for validation
          source "$HOME/.sdkman/bin/sdkman-init.sh"
          echo "âœ… ValidaÃ§Ã£o concluÃ­da - pronto para deploy"
          echo "ðŸ“‹ Java version check:"
          java -version

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-backend-resultados]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: ðŸ” Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ðŸ”’ Security Validation - Port Exposure
        run: |
          # Verificar exposiÃ§Ã£o de portas do Resultados
          if grep -E "^\s*-\s*[\"']?(8081|8082|8083):" docker-compose.yml; then
            echo "âš ï¸ WARNING: Resultados ports may be exposed - ensure firewall protection"
            echo "ðŸ”’ Note: Current configuration works but consider overlay-only for maximum security"
          else
            echo "âœ… No ports exposed - maximum security (overlay network only)"
          fi

      - name: ðŸ” Get secrets from Azure Key Vault (OIDC)
        id: get-secrets
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        uses: azure/CLI@v1
        with:
          azcliversion: 2.76.0
          inlineScript: |
            set -Eeuo pipefail
            echo "ðŸ” Buscando secrets essenciais do Resultados no Key Vault..."
            
            # Obter nome do Key Vault
            KEYVAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME }}"
            
            # Verificar autenticaÃ§Ã£o Azure
            echo "ðŸ” Verificando autenticaÃ§Ã£o Azure..."
            if ! az account show >/dev/null 2>&1; then
              echo "âŒ Azure CLI nÃ£o autenticado - execute o login Azure OIDC primeiro"
              exit 1
            fi
            
            # Lista de secrets essenciais para o serviÃ§o Resultados
            essential_secrets=(
              "conexao-de-sorte-database-r2dbc-url"
              "conexao-de-sorte-database-username"
              "conexao-de-sorte-database-password"
              "conexao-de-sorte-redis-host"
              "conexao-de-sorte-redis-port"
              "conexao-de-sorte-redis-password"
              "conexao-de-sorte-redis-database"
              "conexao-de-sorte-rabbitmq-host"
              "conexao-de-sorte-rabbitmq-port"
              "conexao-de-sorte-rabbitmq-username"
              "conexao-de-sorte-rabbitmq-password"
              "conexao-de-sorte-rabbitmq-vhost"
              "conexao-de-sorte-jwt-secret"
              "conexao-de-sorte-jwt-issuer"
              "conexao-de-sorte-server-port"
            )
            
            essential_count=0
            for secret in "${essential_secrets[@]}"; do
              echo "ðŸ” Tentando obter: $secret"
              if value=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "$secret" --query "value" -o tsv 2>/dev/null); then
                if [[ -n "$value" && "$value" != "null" ]]; then
                  # ValidaÃ§Ãµes de seguranÃ§a para senhas e secrets crÃ­ticos
                  if [[ "$secret" == *"password"* || "$secret" == *"jwt-secret"* ]]; then
                    # Validar tamanho mÃ­nimo (mÃ­nimo 8 caracteres)
                    if [[ ${#value} -lt 8 ]]; then
                      echo "âŒ Secret $secret muito curto (mÃ­nimo 8 caracteres)" >&2
                      exit 1
                    fi
                    # Validar que nÃ£o Ã© uma senha padrÃ£o/fraca
                    if [[ "$value" =~ ^(12345678|password|admin|root|teste|senha)$ ]]; then
                      echo "âŒ Secret $secret usa valor padrÃ£o/inseguro" >&2
                      exit 1
                    fi
                  fi
                  
                  # Converte o nome do secret para variÃ¡vel de ambiente (UPPERCASE + _)
                  var_name=$(echo "$secret" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
                  echo "$var_name=$value" >> "$GITHUB_ENV"
                  echo "::add-mask::$value"
                  echo "âœ… $secret obtido e validado (len=${#value}) => exportado como $var_name"
                  essential_count=$((essential_count + 1))
                else
                  echo "âš ï¸ $secret encontrado mas vazio"
                fi
              else
                echo "âš ï¸ $secret nÃ£o encontrado no Key Vault"
              fi
            done
            
            echo "ðŸ“Š Total de secrets essenciais obtidos: $essential_count/${#essential_secrets[@]}"
            if [[ $essential_count -ge 10 ]]; then
              echo "âœ… Secrets suficientes e validados para deploy (mÃ­nimo 10/15)"
            else
              echo "âŒ Poucos secrets obtidos - deploy serÃ¡ abortado"
              exit 1
            fi

      - name: ðŸŒ Preparar rede overlay compartilhada
        env:
          NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          set -euo pipefail
          echo "ðŸ” Verificando rede overlay: $NETWORK_NAME"

          if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
            echo "ðŸ—ï¸ Criando rede overlay compartilhada: $NETWORK_NAME"
            docker network create \
              --driver overlay \
              --attachable \
              --subnet=10.10.0.0/16 \
              --gateway=10.10.0.1 \
              "${NETWORK_NAME}"
            echo "âœ… Rede overlay criada: $NETWORK_NAME"
          else
            echo "âœ… Rede overlay jÃ¡ existe: $NETWORK_NAME"
          fi

      - name: ðŸ§¹ Cleanup anterior (Resultados)
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          set -euo pipefail
          echo "ðŸ§¹ Iniciando limpeza de recursos anteriores..."

          # 1. Graceful shutdown: scale services to 0 replicas
          if docker service ls --filter name="$STACK_NAME" --format '{{.Name}}' | grep -q "^$STACK_NAME"; then
            echo "ðŸ”„ Scaling down serviÃ§os do stack $STACK_NAME..."
            for service in $(docker service ls --filter name="$STACK_NAME" --format '{{.Name}}'); do
              echo "  - Scaling down: $service"
              docker service scale "$service=0" >/dev/null 2>&1 || true
            done
            sleep 10
          fi

          # 2. Remove stack
          if docker stack ls --format '{{.Name}}' | grep -q "^$STACK_NAME\$"; then
            echo "ðŸ—„ï¸ Removendo stack: $STACK_NAME"
            docker stack rm "$STACK_NAME"
            sleep 15
          fi

          # 3. Clean orphan containers
          echo "ðŸ§¹ Limpando containers Ã³rfÃ£os relacionados ao Resultados..."
          orphan_containers=$(docker ps -a --filter name="*resultados*" --format '{{.ID}} {{.Names}}' | grep -E "(resultados|$STACK_NAME)" || true)
          if [[ -n "$orphan_containers" ]]; then
            echo "$orphan_containers" | while read container_id container_name; do
              if [[ -n "$container_id" ]]; then
                echo "  ðŸ—‘ï¸ Removendo container Ã³rfÃ£o: $container_name ($container_id)"
                docker stop "$container_id" >/dev/null 2>&1 || true
                docker rm "$container_id" >/dev/null 2>&1 || true
              fi
            done
          fi

          # 4. Image cleanup (keep 3 recent versions)
          echo "ðŸ§¹ Limpando imagens antigas do Resultados (mantendo 3 versÃµes recentes)..."
          old_images=$(docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep -E "(resultados|ghcr.io.*resultados)" | tail -n +4 || true)
          if [[ -n "$old_images" ]]; then
            echo "$old_images" | while read image_id image_tag; do
              if [[ -n "$image_id" && "$image_tag" != *"<none>"* ]]; then
                echo "  ðŸ—‘ï¸ Removendo imagem antiga: $image_tag ($image_id)"
                docker rmi "$image_id" >/dev/null 2>&1 || true
              fi
            done
          fi

          echo "âœ… Limpeza concluÃ­da"

      - name: ðŸš€ Deploy Resultados Stack (Swarm-Only)
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          COMPOSE_FILE: docker-compose.yml
          # Environment variables from Key Vault (mÃ©todo manual - padrÃ£o Gateway)
          DATABASE_R2DBC_URL: ${{ env.CONEXAO_DE_SORTE_DATABASE_R2DBC_URL }}
          DATABASE_USERNAME: ${{ env.CONEXAO_DE_SORTE_DATABASE_USERNAME }}
          DATABASE_PASSWORD: ${{ env.CONEXAO_DE_SORTE_DATABASE_PASSWORD }}
          REDIS_HOST: ${{ env.CONEXAO_DE_SORTE_REDIS_HOST }}
          REDIS_PORT: ${{ env.CONEXAO_DE_SORTE_REDIS_PORT }}
          REDIS_PASSWORD: ${{ env.CONEXAO_DE_SORTE_REDIS_PASSWORD }}
          REDIS_DATABASE: ${{ env.CONEXAO_DE_SORTE_REDIS_DATABASE }}
          RABBITMQ_HOST: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_HOST }}
          RABBITMQ_PORT: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_PORT }}
          RABBITMQ_USERNAME: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_USERNAME }}
          RABBITMQ_PASSWORD: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_PASSWORD }}
          RABBITMQ_VHOST: ${{ env.CONEXAO_DE_SORTE_RABBITMQ_VHOST }}
          JWT_SECRET: ${{ env.CONEXAO_DE_SORTE_JWT_SECRET }}
          JWT_ISSUER: ${{ env.CONEXAO_DE_SORTE_JWT_ISSUER }}
          SERVER_PORT: ${{ env.CONEXAO_DE_SORTE_SERVER_PORT }}
        run: |
          echo "ðŸš€ Iniciando deploy do Resultados com Docker Swarm..."

          echo "ðŸ—ï¸ Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "â° Aguardando estabilizaÃ§Ã£o dos serviÃ§os Resultados..."
          sleep 35

      - name: ðŸ” Healthcheck Resultados
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          echo "ðŸ” Validando saÃºde do Resultados..."

          timeout=200
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            RESULTADOS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_resultados" | head -1)

            if [ -n "$RESULTADOS_CONTAINER" ]; then
              echo "ðŸ” Testando health check do Resultados... ($elapsed/$timeout segundos)"

              # Check 1: Process validation
              if docker exec "$RESULTADOS_CONTAINER" ps aux 2>/dev/null | grep -q "[j]ava\|[s]pring"; then
                echo "âœ… Resultados health check passed (process validation)"
                health_passed=true
                break
              fi

              # Check 2: Log validation
              if docker logs "$RESULTADOS_CONTAINER" 2>/dev/null | grep -q "Started.*Application\|Tomcat started\|Started ResultadosApplication"; then
                echo "âœ… Resultados health check passed (logs validation)"
                health_passed=true
                break
              fi

              echo "â³ Resultados ainda nÃ£o estÃ¡ pronto... ($elapsed/$timeout segundos)"
            else
              echo "â³ Container Resultados ainda nÃ£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "âš ï¸ Resultados health check nÃ£o passou em $timeout segundos"
            echo "ðŸ” Verificando logs finais do Resultados..."
            if [ -n "$RESULTADOS_CONTAINER" ]; then
              echo "--- Ãšltimos 30 logs do Resultados ---"
              docker logs "$RESULTADOS_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "ðŸ’¡ Nota: Resultados pode estar funcionando mesmo com health check parcial"
            exit 1
          else
            echo "âœ… Resultados health check concluÃ­do com sucesso!"
          fi

      - name: ðŸ”— Connectivity Validation
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          DOCKER_NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          echo "ðŸ”— Validando conectividade do Resultados..."

          if docker service ls | grep -q "${STACK_NAME}_resultados"; then
            echo "âœ… ServiÃ§o Resultados encontrado no Swarm"
          else
            echo "âŒ ServiÃ§o Resultados nÃ£o encontrado no Swarm"
            exit 1
          fi

          if docker network inspect "$DOCKER_NETWORK_NAME" | grep -q resultados; then
            echo "âœ… Resultados conectado Ã  rede overlay"
          else
            echo "âš ï¸ Resultados pode nÃ£o estar na rede overlay correta"
          fi

          echo "ðŸ“Š Status final dos serviÃ§os:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: ðŸ§¼ Limpeza de recursos no servidor
        if: success()
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          set -euo pipefail
          before_usage=$(mktemp)
          after_usage=$(mktemp)
          docker system df > "$before_usage"
          echo "ðŸ§¹ Removendo containers parados (â‰¥12h)..."
          docker container prune -f --filter "until=12h"
          echo "ðŸ§¹ Removendo imagens nÃ£o utilizadas (â‰¥7d)..."
          docker image prune -f --filter "until=168h"
          echo "ðŸ§¹ Removendo caches de build antigos (â‰¥7d)..."
          docker builder prune -f --filter "until=168h" || true
          docker system df > "$after_usage"
          echo "ðŸ“¦ Uso de recursos apÃ³s limpeza:"
          cat "$after_usage"
          {
            echo "## Limpeza de recursos no servidor"
            echo ""
            echo "### Uso antes"
            sed 's/^/    /' "$before_usage"
            echo ""
            echo "### Uso depois"
            sed 's/^/    /' "$after_usage"
          } >> "$GITHUB_STEP_SUMMARY"
          rm -f "$before_usage" "$after_usage"