name: "ðŸŽ¯ Resultados Backend - CI/CD Pipeline (Self-hosted Deploy)"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SERVICE_NAME: resultados
  STACK_NAME: conexao-resultados
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write
  contents: read

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "âœ… docker-compose.yml vÃ¡lido"

      - name: Security Validation
        run: |
          echo "ðŸ” Verificando senha hardcoded em docker-compose.yml..."
          if grep -nE "password\s*:\s*[^[:space:]]+" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external"; then
            echo "âŒ Encontrada senha potencialmente hardcoded"
            exit 1
          fi
          echo "âœ… Sem senhas hardcoded detectadas"

      - name: "ðŸ”Ž Validar configuraÃ§Ã£o bÃ¡sica"
        run: |
          echo "âœ… ValidaÃ§Ã£o bÃ¡sica concluÃ­da"

      - name: Validation completed
        run: echo "âœ… ValidaÃ§Ã£o concluÃ­da - pipeline liberado para deploy"

  build-and-push:
    needs: validate-and-build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

      - name: Build with Maven
        run: mvn clean package -DskipTests

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/wibson82/conexao-de-sorte-backend-resultados:latest

  deploy-selfhosted:
    needs: [validate-and-build, build-and-push]
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-backend-resultados]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: "ðŸ” Azure Login (OIDC)"
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: "âœ… Validar sessÃ£o Azure"
        run: |
          echo "ðŸ” Validando sessÃ£o Azure..."
          az account show >/dev/null 2>&1 || { echo "âŒ Falha na autenticaÃ§Ã£o Azure"; exit 1; }
          echo "âœ… Azure autenticado (subscription $(az account show --query id -o tsv))"

      - name: "ðŸ”‘ Get secrets from Azure Key Vault (via AZ CLI)"
        run: |
          echo "ðŸ”‘ Obtendo secrets do projeto Resultados do Azure Key Vault..."

          # Secrets essenciais para o projeto Resultados (R2DBC ONLY)
          # Obter URL R2DBC do banco e corrigir hostname para Docker Swarm
          DATABASE_R2DBC_BASE=$(az keyvault secret show --name conexao-de-sorte-database-r2dbc-url --vault-name kv-conexao-de-sorte --query value -o tsv)

          # Corrigir hostname para usar o service name correto do MySQL no Docker Swarm
          DATABASE_R2DBC_CORRECTED=$(echo "$DATABASE_R2DBC_BASE" | sed 's|conexao-mysql:3306|conexao-mysql_mysql:3306|g')

          echo "DATABASE_R2DBC_URL=$DATABASE_R2DBC_CORRECTED" >> $GITHUB_ENV
          echo "DATABASE_USERNAME=$(az keyvault secret show --name conexao-de-sorte-database-username --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV
          echo "DATABASE_PASSWORD=$(az keyvault secret show --name conexao-de-sorte-database-password --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV
          echo "REDIS_HOST=$(az keyvault secret show --name conexao-de-sorte-redis-host --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV
          echo "REDIS_PORT=$(az keyvault secret show --name conexao-de-sorte-redis-port --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=$(az keyvault secret show --name conexao-de-sorte-redis-password --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV
          echo "REDIS_DATABASE=$(az keyvault secret show --name conexao-de-sorte-redis-database --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV
          echo "JWT_SECRET=$(az keyvault secret show --name conexao-de-sorte-jwt-secret --vault-name kv-conexao-de-sorte --query value -o tsv)" >> $GITHUB_ENV

          echo "âœ… Secrets do projeto Resultados obtidos do Azure Key Vault"

      - name: "ðŸ”’ Provide Docker Secrets from Azure Key Vault"
        run: |
          echo "ðŸ”’ Fornecendo secrets do Azure Key Vault para Docker Swarm..."

          # Funcao para fornecer secret do Azure Key Vault para Docker Swarm
          provide_secret_safe() {
            local secret_name="$1"
            local secret_value="$2"

            echo "Fornecendo secret: $secret_name"

            # Verificar se secret existe e remover se necessÃ¡rio
            if docker secret ls --format "{{.Name}}" | grep -q "^${secret_name}$"; then
              echo "Secret $secret_name jÃ¡ existe - removendo..."
              if ! docker secret rm "$secret_name" 2>/dev/null; then
                echo "âš ï¸ Secret $secret_name estÃ¡ em uso - serÃ¡ atualizado apÃ³s restart do serviÃ§o"
                return 0
              fi
              sleep 1
            fi

            # Fornecer secret do Azure Key Vault para Docker Swarm
            if echo "$secret_value" | docker secret create "$secret_name" - >/dev/null 2>&1; then
              echo "âœ… Secret $secret_name fornecido do Azure Key Vault para Swarm"
            else
              echo "âŒ Falha ao fornecer secret $secret_name"
              return 1
            fi
          }

          # Fornecer os secrets essenciais do Azure Key Vault para Docker Swarm (R2DBC ONLY)
          provide_secret_safe "conexao-de-sorte-database-r2dbc-url" "$DATABASE_R2DBC_URL"
          provide_secret_safe "conexao-de-sorte-database-username" "$DATABASE_USERNAME"
          provide_secret_safe "conexao-de-sorte-database-password" "$DATABASE_PASSWORD"
          provide_secret_safe "conexao-de-sorte-redis-host" "$REDIS_HOST"
          provide_secret_safe "conexao-de-sorte-redis-port" "$REDIS_PORT"
          provide_secret_safe "conexao-de-sorte-redis-password" "$REDIS_PASSWORD"
          provide_secret_safe "conexao-de-sorte-redis-database" "$REDIS_DATABASE"
          provide_secret_safe "conexao-de-sorte-jwt-secret" "$JWT_SECRET"

          echo "ðŸ” Secrets do Azure Key Vault fornecidos para Docker Swarm"

      - name: ðŸ§¹ Preparar ambiente local
        run: |
          echo "ðŸ“ Verificando arquivos para deploy..."
          [[ -f docker-compose.yml ]] || { echo "âŒ docker-compose.yml nÃ£o encontrado"; exit 1; }
          mkdir -p logs
          echo "ðŸ”§ Garantindo rede compartilhada ${DOCKER_NETWORK_NAME}"
          if ! docker network ls --filter name="^${DOCKER_NETWORK_NAME}$" --format '{{.Name}}' | grep -q "${DOCKER_NETWORK_NAME}"; then
            docker network create --driver overlay --attachable "${DOCKER_NETWORK_NAME}"
          fi

      - name: ðŸ³ Deploy Docker Stack
        run: |
          set -Eeuo pipefail
          echo "ðŸš€ Deploy da stack ${STACK_NAME}"
          docker stack deploy -c docker-compose.yml "${STACK_NAME}"
          echo "âœ… Stack enviada"

      - name: ðŸ¥ Health Check Melhorado
        run: |
          echo "â³ Aguardando serviÃ§o ficar saudÃ¡vel"
          STACK_NAME="${STACK_NAME:-conexao-resultados}"
          SERVICE_NAME="${STACK_NAME}_conexao-de-sorte-backend-resultados"

          # Aguardar serviÃ§o ser criado
          echo "ðŸ” Verificando se serviÃ§o foi criado..."
          for attempt in {1..10}; do
            if docker service ls --filter name="$SERVICE_NAME" --format "{{.Name}}" | grep -q .; then
              echo "âœ… ServiÃ§o $SERVICE_NAME encontrado"
              break
            fi
            echo "â³ Tentativa $attempt/10 - aguardando criaÃ§Ã£o do serviÃ§o..."
            sleep 5
          done

          # Verificar se containers estÃ£o rodando
          echo "ðŸ” Verificando containers do serviÃ§o..."
          docker service ps "$SERVICE_NAME" --no-trunc

          # Aguardar containers estarem rodando
          echo "â³ Aguardando containers ficarem operacionais..."
          sleep 60

          # Verificar logs para debug
          echo "ðŸ” Verificando logs do serviÃ§o:"
          docker service logs "$SERVICE_NAME" --tail 20 || true

          # Health check melhorado
          echo "ðŸ¥ Executando health check..."
          attempts=0
          max_attempts=20

          until curl -fsS http://localhost:8087/actuator/health >/dev/null 2>&1; do
            attempts=$((attempts+1))
            if [ $attempts -ge $max_attempts ]; then
              echo "âŒ ServiÃ§o nÃ£o ficou saudÃ¡vel apÃ³s $max_attempts tentativas"

              echo "ðŸ” Logs finais do container:"
              docker service logs "$SERVICE_NAME" --tail 50

              echo "ðŸ“Š Status dos serviÃ§os:"
              docker service ls --filter name="${STACK_NAME}_"

              echo "ðŸ³ Status dos containers:"
              docker ps --filter name="${STACK_NAME}"

              echo "ðŸ” Secrets disponÃ­veis:"
              docker secret ls | grep conexao-de-sorte

              exit 1
            fi
            echo "â³ Health check tentativa $attempts/$max_attempts..."
            sleep 15
          done

          echo "âœ… Health check OK - serviÃ§o estÃ¡ saudÃ¡vel!"

          # Teste final de conectividade
          echo "ðŸ§ª Teste final de conectividade:"
          curl -s http://localhost:8087/actuator/health | head -3

  summary:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: ðŸ“Š Resumo
        run: |
          echo "## ðŸŽ¯ Deploy resultados" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ needs.deploy-selfhosted.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ServiÃ§o: ${SERVICE_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- Stack: ${STACK_NAME}" >> $GITHUB_STEP_SUMMARY
